・binary-treeで、目的のノードのidを発見するのにかかる時間を計る
    -Kanonで上手く描画できるデータ構造定義と、そうでない定義の両方を試す
    -ノード数は100~200くらい？（紙に印刷するので描画にはいくら時間がかかってもよい）
・trie-tree（三分探索木）でどの単語が格納されているかを列挙するまでにかかる時間を計る
・binary-treeの入ったリストでの目的ノードを発見
・リストの参照先を間違えているノードの発見
・リストinリストでの目的ノードの発見
・リストが入っている二分木での目的ノードの発見
・図示された図からデータ構造の種類を特定する
・先に人間に描いてもらった絵と比較する（ソースコードを見せながら）

ノード数100程度の平衡二分木
ある値を持ったのノードを挿入するときにどこに挿入されるかを発見し、入る葉のidをテスト形式で記入してもらう

ノード数50程度のトライ木
どの単語が入っているかを列挙してもらう
（全ての単語を列挙するのは大変なので、「格納されていない単語」をテスト形式にするのもいいかも？）

ノード数150程度のtree of list
一つだけ参照先が間違えているノードがありそこの部分だけ形が崩れているはずなのでそのノードのidを記入してもらう

図示されたデータ構造を見せて、そのデータ構造の種類を特定してもらう（クラス図を描いてもらう）
（簡単なリスト、ツリーや複雑な入れ子構造になってるものまで）





ーーーーーーーーーーーーーーーーー
具体例
ーーーーーーーーーーーーーーーーー

・平衡二分木
    用途：電話番号から素早く個人名を検索できるような電話帳
    実装：各ノードは電話番号と個人名の二つの情報を持っており、平衡二分木によってノードの検索や追加・削除がしやすくなっている
    ユーザーテスト：特定の番号のオブジェクト（例えば110みたいな）だけ使用を変えたい。そのため、ツリーに挿入された後にオブジェクトを直接いじる必要がある
    ノード数：150～200くらい？
    デバッグのときにノードを順に追っていくような具体例が欲しい？
        ・ソートされた木で一部分だけ順番が違う（例えば、苗字でソートして苗字が同じ場合は名前でソートするが、名前のソートのプログラムにミスがあった場合など）ような
        木をオリジナルのレイアウトと新しいレイアウトで比較し、どこに間違いがあるかを見つけてもらう。
        自分で実際にレイアウトした図を使って時間を計ってみよう
            =>人名リストどうしよう？

・トライ木
    用途：高速に検索できる辞書
    実装：三分探索木。各ノードは一つのアルファベットを持っている
    ユーザーテスト：他のプログラムで作られた三分探索木のオブジェクトから、どの単語が格納されているのかを羅列してもらう
    ノード数：50くらい？
    格納単語：xeno, xmas, x-ray, xebec, xenon, xeric, xerox, xerus, xylem, xanadu, xenial, xyloid, xystus, xanthic, xanthus, xenopus, xerotes, xiphias, xiphoid, xylitol,
            xenolith, xanthippe, xerophyte, xylophone, xenogeneic, xenophilic, xenophobia, xylography
            (ｘで始まる単語にしているのは、一般の人が聞きなじみのない単語のほうがより正確にテスト結果が出ると思ったため)
    単語数20くらいが良さげ？
        ・これも自分で図を使って時間を計ってみよう
        単語数20だと苦痛かも？

・ツリーが格納されているリスト
    用途：
        ・複合データ構造（グラフが格納されているリストや、リストが格納されているツリーなど）をもう少し考えてみる
        ・具体例まで考える
            素集合データ構造の例が使えそう
            例)人名リストを素集合データ構造(Union-Find木)で管理したい。
            　　集合は、同じ学校に所属している生徒を表し、その集合の代表値は生徒会長を表す。
            　　生徒会長はリストで実装し、生徒の挿入・削除が行いやすいように、各木は赤黒木で実装する。
            　　ここで、データの参照関係が崩れている部分を発見し、コードのバグを見つけさせる。
                    ・学校の数は6～7個？
                    ・全生徒数は120人くらい？
            [10/3追記]
            一つのノードが可変数個の子ノードを持つような場合の問題点
            ・ 実装には配列を使うことになるが、配列をKanonでレイアウトすると親ノードと子ノードの間にArrayノードができてしまうため、辺の角度決定アルゴリズムが上手く機能しなくなる
            ・Arrayノードから出るエッジは順に0～の数字が名前として付けられるが、それぞれの数字のエッジの角度を揃えられるとかえってグラフが見辛くなる
            ＝＝＞配列のレイアウト方法をなんとかしたい（今後の課題？）

        ・別の具体例
            可変数個の子ノードを持つ木ではなく、二分木をリストに格納したような例が実装上では良さげ
            Kanonオリジナルのレイアウトと区別するため、クラス名をNode、フィールド名をleft・rightなどにする
            例）リスト：製品を取り扱っている店、ツリー：各商品の製品番号を表すようなデータ構造
                各店舗毎の商品の検索を早めるため、ツリーは赤黒木で実装
                新しい店舗の挿入や閉店した店舗の削除のことを考えて店舗はリストで実装


+人に書いてもらうようなやつ
    微妙なもの

図を見てクラス定義を類推してもらう
        ・これも具体例をもう少し考えてみる
        